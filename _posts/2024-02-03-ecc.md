---
layout: post
title: "Criptografia de Curvas El√≠pticas: MenezesQuVanstone, ECDSA e Ataques"
date: 2024-02-3 00:20:00
description: Material Did√°tico sobre Criptografia de Curvas El√≠pticas com toda a matem√°tica necess√°ria.
tags: ECC
categories: Intermedi√°rio
thumbnail: assets/img/ECC/thumbnail_ecc.gif
chart:
  vega_lite: true
---

## 1. Teoria dos Grupos

Para introduzir esse conceito, surigo uma alus√£o:

Suponha que exista um grupo de 5 amigos que s√£o pr√≥ximos e outro grupo de 5 colegas de trabalho que n√£o interagem muito, respectivamente $$G_1, G_2$$. Entre eles, podem interagir de formas distintas como um aperto de m√£os ou abra√ßo.

N√£o √© um salto muito grande afirmar que os amigos do grupo $$G_1$$ se abra√ßam, j√° que s√£o pr√≥ximos, mas para os colegas de trabalho do grupo $$G_2$$ talvez n√£o seja t√£o apropriado, sendo mais prov√°vel se apresentarem com um aperto de m√£os.

Para os dois grupos distintos, s√£o estabelecidas formas de comunica√ß√£o diferentes, seja o aperto de m√£o ou o abra√ßo, e na Matem√°tica n√£o √© t√£o diferente.

## 1.1. Defini√ß√£o:

Um grupo pode ser descrito como um conjunto de $$n$$ elementos e um operador de grupo, como adi√ß√£o ou multiplica√ß√£o.

Se um grupo $$G$$ tem dois elementos $$a$$ e $$b$$ e seu operador for multiplica√ß√£o, $$c=a \times b$$.

Para tal ser chamado de grupo, ele deve necessariamente respeitar os axiomas abaixo:

- Fechado: $$a\ 0 \ b =c \in G$$
- Associatividade: $$(a \ 0 \ b) \ 0 \ c = a \ 0 \ (b \ 0 \ c) \in G$$
- Elemento Neutro: $$a \ 0 \ 1 = a$$, onde 1 √© o elemento neutro nesse caso
- Elemento Inverso: $$a \ 0 \ a^{-1}=1$$

Contudo, para a criptografia de curva el√≠tpicas vamos usar um grupo espec√≠fico que ser√° essencial para o Diffie-Hellman, o Grupo Abeliano, que tem uma mais propriedade:

- Comutatividade: $$a \ 0 \ b = b \ 0 \ a \in G$$

## 1.2. Grupo Finito

Um grupo √© finito se tem um n√∫mero finito de elementos, onde sua cardinalidade √© denotada por $$\# G$$. Por exemplo, $$‚Ñ§_9=\{0,1,2,3,4,5,6,7,8\}$$, ent√£o sua cardinalidade √© 9.

## 1.3. Ordem de um Elemento:

A ordem de um elemento $$a$$ de um grupo $$(G, 0)$$ √© o menor inteiro $$k$$ que satisfa√ßa:

$$
a^k= \underbrace{a \ 0 \ a \dots  a \ 0 \ a }_\text{k vezes}=1
$$

onde 1 √© o elemento neutro desse grupo $$G$$.

Vamos determinar a ordem de $$3$$ em $$‚Ñ§_5^*$$:

$$
3^1 \equiv 3 \mod5
$$

$$
3^2 \equiv4 \mod5
$$

$$
3^3 \equiv 2 \mod5
$$

$$
3^4 \equiv 1 \mod5
$$

Portanto, a ordem de 3 no grupo √©: $$ord(3)=4$$, que √© justamente $$\# ‚Ñ§_5^*$$

N√£o foram necess√°rias muitas opera√ß√µes para alcan√ßar o elemento neutro do grupo, mas se continuarmos vamos observar um comportamento bem interessante:

$$
3^5 \equiv 3 \mod5
$$

$$
3^6 \equiv4 \mod5
$$

$$
3^7 \equiv 2 \mod5
$$

$$
3^8 \equiv 1 \mod5
$$

A sequ√™ncia de $$\{3,4,2,1\}$$ vai se repetir para sempre, contudo isso n√£o √© o suficiente para afirmar que esse √© um grupo c√≠clico, ao menos sem saber do Teorema 1.

### Teorema 1:

Para um $$p$$ primo, todo grupo $$(‚Ñ§_p^*, 0)$$ √© **_finito_**, **_abeliano_** e **_c√≠clico._**

Segue o c√≥digo em Python que encontra os geradores de um grupo $$‚Ñ§^*_n, n>2$$:

```python
def encontra_gerador(n): # Recebe m√≥dulo n
  for x in range(2, n):
    cont = 1
    for i in range(1, n):
      if ((x ** i) % n) == 1 and cont == n-1:
        print(f"{x} √© gerador do grupo ‚Ñ§*_{n}")
        break
      cont += 1
```

## 1.4. Grupo C√≠clico:

Um grupo $$G$$ √© c√≠clico se o elemento de ordem m√°xima √© a pr√≥pria cardinalidade do grupo $$\#G$$. Esses elementos s√£o os **_geradores_** do grupo.

No exemplo anterior foi encontrado um gerador sem saber o que era um. Perceba:

$$‚Ñ§_5^*=\{1,2,3,4\},$$ e portanto $$\#‚Ñ§_5^*=4$$, que √© a ordem do elemento 3 no grupo.

Segue que, o grupo $$‚Ñ§_5^*$$ √© c√≠clico e $$3$$ √© um dos elementos geradores desse grupo.

Pode-se ir al√©m e afirmar que todos os elementos desse grupo s√£o geradores, pelo **Teorema 2**.

### 1.4.1. Propriedades dos Grupos C√≠clicos:

Seja o grupo c√≠clico $$G$$ de cardinalidade $$\# G$$, ent√£o $$\forall a \in G$$ vale que:

$$
a^{\#G} \equiv 1\mod(\#G+1)
$$

$$
ord(a) \mid \#G
$$

A primeira propriedade vem do Pequeno Teorema de Fermat para $$‚Ñ§_p^*:$$

O grupo $$‚Ñ§_p^*=\{1, 2, ..., (p-1)\}$$ tem cardinalidade $$(p-1)$$, e portanto:

$$
a^{(p-1)}\equiv1 \mod p
$$

J√° a segunda propriedade diz que a cardinalidade do grupo √© divis√≠vel pelas ordens dos elementos dele. Logo, em $$‚Ñ§_{11}^*=\{1,2,3,4,5,6,7,8,9,10\}$$ as ordens dos elementos s√£o:

$$
ord(a)=\{1,2,5,10\}
$$

## 2. Problema do Logaritmo Discreto:

Grupos c√≠clicos s√£o importantes para problemas de logaritmo discreto, pois a partir de um gerador $$\alpha$$ no grupo $$‚Ñ§_p^*$$ √© poss√≠vel encontrar todos os elementos desse Grupo.

Exemplo:

Em $$‚Ñ§_{47}^*$$ todos os elementos s√£o geradores como foi falado no Teorema 1 , ent√£o se pegarmos um $$\alpha=5$$, √© poss√≠vel encontrar todos os elementos do Grupo a partir de $$\alpha$$.

Dito isso, encontre $$x$$:

$$
5^x\equiv\ 41 \mod47,
$$

Talvez voc√™ j√° tenha percebido que essa conta manualmente √© extremamente complicada, pois exige o c√°lculo de

$$
x\equiv \log_5 41 \mod 47
$$

Contudo, como esse √© um problema que envolve n√∫meros pequenos, com um simples brute-force √© encontrado o valor de $$x$$.

Vale ressaltar que, $$x$$ respeita a desigualdade $$1 \leq x \leq 46$$ pelo Pequeno Teorema de Fermat, pois

$$
a^{(p-1)}\equiv1 \mod p
$$

Assim, ele reinicia a sequ√™ncia do Grupo C√≠clico no elemento neutro $$1$$.

Segue abaixo o c√≥digo em Python que realiza esse brute-force ing√™nuo:

```python
def DLP_bruteforce_dumb(p, alpha, beta):
	for x in range(1, mod):
		if (alpha**x % p == beta):
			return x
```

Se voc√™ rodar esse c√≥digo com os par√¢metros $$\alpha=5, \ \beta =41$$ e $$p=47$$ √© retornado $$x=15$$ em pouco tempo, porque esse problema est√° lidando com n√∫meros bem pequenos e eles n√£o seriam usados de forma alguma em um sistema de criptografia.

Portanto, o problema do logaritmo discreto pode ser sintetizado em

Dados $$p, \beta \in ‚Ñ§_{p}^*$$ e o gerador $$\alpha$$, encontre $$x$$ que satisfa√ßa a condi√ß√£o abaixo:

$$
\alpha^x\equiv\beta \mod p
$$

que √© resolvido por

$$
x \equiv \log_\alpha \beta \mod p
$$

## 3. Curvas El√≠pticas

Por defini√ß√£o, uma curva el√≠ptica em $$‚Ñ§_p,\  p>3$$ √© o conjunto de todos os pares coordenados $$(x,y) \in ‚Ñ§_p$$ que satisfazem

$$
y^2\equiv x^3+ax+b \mod p
$$

onde $$a,b \in ‚Ñ§_p$$. Al√©m de um ponto imagin√°rio no infinito denotado por¬†$$O$$, e o discriminante $$4a^3+27b^2\ne0$$, para que sejam curvas regulares.

Quando essa curva √© regular e se pode definir uma opera√ß√£o para o conjunto de pontos nela pertencentes, ela se torna um Grupo Abeliano.

Caso ainda exista d√∫vida, verificamos se um ponto $$P$$ pertence √† curva se for verdade $$y^2-x^3-ax-b\equiv0 \mod p$$.

Toda curva el√≠ptica que atenda a essas condi√ß√µes √© sim√©trica em rela√ß√£o ao eixo $$x$$ e isso √© f√°cil de verificar:

Seja a curva el√≠ptica $$E:y^2=x^3-2x+2$$ no plano cartesiano, ao ‚Äútirar a raiz‚Äù de ambos os lados da equa√ß√£o obtemos

$$
y=\pm\sqrt{x^3-2x+2}
$$

<div class="row mt-3">
    <div class="col-sm mt-3 mt-md-0">
        {% include figure.liquid path="assets/img/ECC/plot.png" class="img-fluid rounded z-depth-1" %}
    </div>
    <div class="col-sm mt-3 mt-md-0">
    </div>
</div>
<div class="caption">
    A simple, elegant caption looks good between image rows, after each row, or doesn't have to be there at all.
</div>


## 4. Grupos em Curvas El√≠pticas:

Para definir um grupo, √© preciso um conjunto finito de elementos e um operador de grupo, s√£o eles:

- O conjunto de pontos $$(x,y) \in E:y^2\equiv x^3 + ax + b \mod p$$
- Operador de Adi√ß√£o $$(+)$$.

A curva el√≠ptica $$E$$ √© um Grupo Aditivo, e isso significa que vamos obter pontos a partir da soma bin√°ria deles.

$$
P+Q =R
$$

onde $$P=(x_1, y_1), Q=(x_2,y_2) \ e  \ R=(x_3,y_3)$$.

Para isso acontecer, devemos garantir que o axioma 1 (Fechado) dos Grupos seja respeitado, _mas como?_

### 4.1. Adi√ß√£o de Pontos $$(P \neq Q)$$:

Nesse cen√°rio, o ponto $$R$$ √© obtido ao tra√ßar uma reta entre os pontos $$P \ e \ Q$$, que intersecta a curva em outro ponto, digamos $$R'$$. Por fim, esse ponto √© espelhado em rela√ß√£o ao eixo $$x$$ da seguinte maneira

$$
R'=(x_{R'}, y_{R'}) \rightarrow R=(x_{R'}, -y_{R'})
$$

que √© por defini√ß√£o $$R=-R'$$.

Exemplo:

Sejam a curva el√≠ptica $$E:y^2= x^3+ax+b$$ e os pontos $$P=(x_P,y_P),Q=(x_Q,y_Q) \in E$$.

A reta $$r$$ que passa por $$P \ e \ Q$$ tem equa√ß√£o $$y=sx+m$$, onde $$s$$ √© o coeficiente angular dessa reta.

Lembrando que o coeficiente angular de uma reta em $$‚Ñù$$ √© dado por:

$$
s=\frac{y_Q-y_P}{x_Q-x_P}
$$

Mas vale ressaltar que, em $$‚Ñ§_p$$ √© usado o Algoritmo de Euclides Estendido para encontrar o inverso multiplicativo:

$$
s\equiv(y_Q-y_R)(x_Q-x_P)^{-1} \mod p
$$

Substituindo $$y$$ na curva $$E$$ √© obtido:

$$
(sx+m)^2=x^3+ax+b
$$

$$
s^2x^2+2smx+m^2=x^3+ax+b
$$

$$
x^3-s^2x^2-2smx-m^2+ax+b=0
$$

$$
x^3-s^2x^2+(a-2sm)x+(b-m^2)=0 \ \ \ \ \ \ (1)
$$

Para encontrar $$R$$ √© preciso lembrar da caracter√≠stica de uma equa√ß√£o c√∫bica:

$$
x^3+ax^2+bx+c=0, \ a\neq 0
$$

Uma equa√ß√£o c√∫bica tem tr√™s ra√≠zes, que nesse caso s√£o as coordenadas parciais $$x_P, x_Q, x_R$$. Podemos usar isso na equa√ß√£o caracter√≠stica:

$$
x^3+ax^2+bx+c= (x-x_P)(x-x_Q)(x-x_R)
$$

Expandindo o lado direito da equa√ß√£o:

$$
(x-x_P)(x-x_Q)(x-x_R)=
$$

$$
=(x^2‚àí(x_P+x_Q)x+x_Px_Q)(x‚àíx_R)=
$$

$$
=x^3‚àí(x_P+x_Q+x_R)x^2+(x_Px_Q+x_Px_R+x_Qx_R)x‚àíx_Px_Qx_R
\ \ \ \ \ \ (2)


$$

Podemos igualar os coeficientes das equa√ß√µes **(1)** e **(2)** e encontramos o valor desejado de $$x_R$$.

$$

\begin{cases}
    -s^2x^2= -(x_P+x_Q+x_R)x^2\\
    (a-2sm)x = (x_Px_Q+x_Px_R+x_Qx_R)x \\
    (b-m^2) = -x_Px_Qx_R\\
\end{cases}


$$

Ent√£o:

$$
-s^2=-(x_P+x_Q+x_R)
$$

$$
s^2=(x_P+x_Q+x_R)
$$

Isolando $$x_R$$

$$
x_R=s^2-x_P-x_Q
$$

Como agora temos $$x_R$$, √© poss√≠vel determinar o valor de $$y_R$$ partindo da equa√ß√£o da reta entre $$P \ e \ R$$.

$$
s=\frac{y_R-y_P}{x_R-x_P}
$$

Com uma simples manipula√ß√£o alg√©brica √© encontrado $$y_R$$:

$$
s(x_R-x_P)=y_R-y_P
$$

$$
y_R=s(x_R-x_P)+y_P
$$

Mas ainda falta espelhar esse resultado em rela√ß√£o ao eixo x, ou seja, encontrar $$-y_R$$:

$$
-y_R=-s(x_R-x_P)-y_P
$$

Que √© equivalente a

$$
-y_R=s(x_P-x_R)-y_P
$$

### 4.2. Point Doubling $$(P = Q)$$:

Quando os pontos $$P$$ e $$Q$$ s√£o iguais, o ponto $$R$$ √© resultado de

$$
R=P+Q=P+P=2P
$$

Vamos visualizar geometricamente:

Suponha que existam dois pontos $$P\neq Q\in E$$ arbitrariamente pr√≥ximos e que √© tra√ßada um reta secante passando por $$P \ e \ Q$$.

Imagine que o ponto $$Q$$ vai se aproximando cada vez mais de $$P$$, e que isso acontece de tal maneira que a dist√¢ncia final entre eles seja infinitesimal.

Assim, os pontos $$P, Q$$ v√£o coincidir e a reta s√≥ tocar√° o ponto $$P$$.

Imagem meramente ilustrativa de uma par√°bola. N√£o representa uma curva el√≠ptica.

Essa reta √© a Reta Tangente, que tamb√©m tem equa√ß√£o

$$
y=sx+m
$$

Dessa vez, o coeficiente angular √© dado pela derivada de

$$
y^2=x^3+ax+b
$$

Para isso, vamos derivar primeiro para $$y>0$$:

$$
y=\sqrt{x^3+ax+b}
$$

$$
\frac{dy}{dx}=\frac{d}{dx}(\sqrt{x^3+ax+b})
$$

$$
\frac{dy}{dx}=\frac{d}{dx}(x^3+ax+b)^\frac{1}{2}
$$

Aplica-se a Regra da Cadeia:

$$
\frac{dy}{dx}=\frac{1}{2}(x^3+ax+b)^{-\frac{1}{2}}\cdot(3x^2+a)
$$

$$
\frac{dy}{dx}=\frac{1}{2\sqrt{x^3+ax+b}}\cdot(3x^2+a)
$$

Por fim, √© substituido o valor conhecido de $$y=\sqrt{x^3+ax+b}$$

$$
\frac{dy}{dx}=\frac{1}{2y}\cdot(3x^2+a)
$$

Como $$2y$$ j√° leva em considera√ß√£o o sinal de $$y$$, n√£o √© necess√°rio derivar para $$y<0$$.

$$
s=\frac{3x^2+a}{2y}
$$

Dadas as as equa√ß√µes de $$x_R\ e\  y_R$$, basta substituir o valor de $$s$$.

$$
x_R=s^2-x_P-x_Q
$$

Mas $$P=(x_P,y_P)=Q$$:

$$
x_R=s^2-2x_P
$$

Para $$y_R$$ n√£o √© necess√°rio realizar altera√ß√µes na f√≥rmula:

$$
y_R=s(x_P-x_R)-y_P
$$

### 4.3. Elemento Neutro do Grupo $$(O)$$:

E se a reta que passa por $$P \text{ e } Q$$ for vertical ao eixo x?

Esse cen√°rio ocorre quando $$P=(x,y) \text{  e  } Q=(x,-y)$$.

Para isso, √© definido um ponto no infinito do eixo $$y$$ , denotado por $$O$$. Podemos imaginar uma estrada que vai at√© o infinito, j√° que as margens s√£o retas paralelas e se encontram no horizonte.

P+Q=P+(-P)=O

Estrada que vai at√© o infinito.

Esse ponto no infinito √© o elemento neutro do Grupo Aditivo, isso significa que

$$
P+O=P,\  \forall P\in E
$$

Ou ainda,

$$
P+(-P)=O
$$

Lembrando que, por defini√ß√£o $$-P=(x_P,-y_P)$$, mas em $$‚Ñ§_p$$ √© dado por

$$
-P=(x_P,p-y_P) \mod p
$$

Imagem meramente ilustrativa de uma par√°bola. N√£o representa uma curva el√≠ptica.

Essa reta √© a Reta Tangente, que tamb√©m tem equa√ß√£o

$$
y=sx+m
$$

Dessa vez, o coeficiente angular √© dado pela derivada de

$$
y^2=x^3+ax+b
$$

Para isso, vamos derivar primeiro para $$y>0$$:

$$
y=\sqrt{x^3+ax+b}
$$

$$
\frac{dy}{dx}=\frac{d}{dx}(\sqrt{x^3+ax+b})
$$

$$
\frac{dy}{dx}=\frac{d}{dx}(x^3+ax+b)^\frac{1}{2}
$$

Aplica-se a Regra da Cadeia:

$$
\frac{dy}{dx}=\frac{1}{2}(x^3+ax+b)^{-\frac{1}{2}}\cdot(3x^2+a)
$$

$$
\frac{dy}{dx}=\frac{1}{2\sqrt{x^3+ax+b}}\cdot(3x^2+a)
$$

Por fim, √© substituido o valor conhecido de $$y=\sqrt{x^3+ax+b}$$

$$
\frac{dy}{dx}=\frac{1}{2y}\cdot(3x^2+a)
$$

Como $$2y$$ j√° leva em considera√ß√£o o sinal de $$y$$, n√£o √© necess√°rio derivar para $$y<0$$.

$$
s=\frac{3x^2+a}{2y}
$$

Dadas as as equa√ß√µes de $$x_R\ e\  y_R$$, basta substituir o valor de $$s$$.

$$
x_R=s^2-x_P-x_Q
$$

Mas $$P=(x_P,y_P)=Q$$:

$$
x_R=s^2-2x_P
$$

Para $$y_R$$ n√£o √© necess√°rio realizar altera√ß√µes na f√≥rmula:

$$
y_R=s(x_P-x_R)-y_P
$$

### 4.3. Elemento Neutro do Grupo $$(O)$$:

E se a reta que passa por $$P \text{ e } Q$$ for vertical ao eixo x?

Esse cen√°rio ocorre quando $$P=(x,y) \text{  e  } Q=(x,-y)$$.

Para isso, √© definido um ponto no infinito do eixo $$y$$ , denotado por $$O$$. Podemos imaginar uma estrada que vai at√© o infinito, j√° que as margens s√£o retas paralelas e se encontram no horizonte.

P+Q=P+(-P)=O

Estrada que vai at√© o infinito.

Esse ponto no infinito √© o elemento neutro do Grupo Aditivo, isso significa que

$$
P+O=P,\  \forall P\in E
$$

Ou ainda,

$$
P+(-P)=O
$$

Lembrando que, por defini√ß√£o $$-P=(x_P,-y_P)$$, mas em $$‚Ñ§_p$$ √© dado por

$$
-P=(x_P,p-y_P) \mod p
$$

### Teorema 2:

Os pontos de uma curva el√≠ptica $$E\  (O$$ incluso$$)$$ tem subgrupos c√≠clicos. Sob algumas condi√ß√µes, todos os pontos de $$E$$ formam um Grupo C√≠clico.

### Teorema 3:

Se $$G$$ √© um grupo finito e c√≠clico com $$\#G$$ primo, ent√£o todos os elementos $$a\neq 1 \in G$$ s√£o geradores.

### Teorema 4 (Teorema de Hasse):

Dada uma curva el√≠ptica $$E$$ em $$‚Ñ§_{p}\ ,\ p>3$$, o n√∫mero de pontos na curva √© denotado por $$\# E$$ e √© limitado por:

$$
p+1-2\sqrt{p}\leq\#E\leq p+1+2\sqrt{p}
$$

Para um $$p$$ suficientemente grande,

$$
\#E\approx p
$$

### 4.4. Exemplo Pr√°tico (Understanding Cryptography - Christof Paar, Jan Pelzl):

Seja a curva el√≠ptica $$E:y^2\equiv x^3+2x+2 \mod 17$$:

O valor de $$\#E$$ pode ser calculado de forma exata com o **[tra√ßo de Frobenius](https://www.math.ttu.edu/~mccarthy/publications/TraceFrob.pdf)**, mas a conta √© muito extensa, al√©m de complicada. Fazendo a conta previamente, $$\#E=19$$.

Sabendo que $$\#E$$ √© primo, vale o Teorema 3 e qualquer ponto da curva √© um gerador.

Vamos verificar se $$P=(5,1)$$ pertence a curva:

$$
y^2 - x^3 - 2x-2 \equiv 0 \mod17
$$

$$
1^2 - 5^3 - 2(5)-2 \equiv 0 \mod17
$$

$$
1 -125-10-2 \equiv 0 \mod17
$$

$$
136\equiv 0 \mod 17
$$

Como $$136 \div17=8$$, a congru√™ncia √© verdadeira, e portanto $$P \in E$$.

A partir do gerador $$P=(5,1)$$, vamos computar as adi√ß√µes de $$P$$ at√© chegar no elemento neutro, i.e., $$\#E.$$

Vou fazer manualmente a soma $$2P$$ para fixar o conte√∫do:

$$
s\equiv(3x_P^2+a)(2y_P)^{-1} \mod17
$$

$$
s\equiv(3(5)^2+2)(2)^{-1} \mod17
$$

$$
s\equiv(3\cdot 25+2) \cdot 9\mod17
$$

$$
s\equiv 13\mod17
$$

$$
x_R\equiv s^2-2x_P \mod 17
$$

$$
y_R\equiv s(x_P-x_R)-y_P \mod 17
$$

$$
x_R\equiv (13)^2-2\cdot 5 \mod 17
$$

$$
y_R\equiv 13(5-6)-1 \mod 17
$$

$$
x_R\equiv 6\mod 17
$$

$$
y_R\equiv 3\mod 17
$$

$$
2P=(6,3)
$$

E assim segue,

$$
2P=(6,3)\\
$$

$$
3P=2P+P=(10,6) \\
$$

$$
4P=3P+P=(3,1) \\
$$

$$
5P=(9,16) \\
$$

$$
6P=(16,13)\\
$$

$$
7P=(0,6)\\
$$

$$
8P=(13,7)\\
$$

$$
9P=(7,6)\\
$$

$$
10P=(7,11)
$$

$$
11P=(13,10)\\
$$

$$
12P=(0,11)\\
$$

$$
13P=(16,4)\\
$$

$$
14P=(9,1)\\
$$

$$
15P=(3,16)\\
$$

$$
16P=(10,11)\\
$$

$$
17P=(6,14)\\
$$

$$
18P=(5,16)=(5,-1)=-P\\
$$

$$
19P=P+(-P)=O
$$

Perceba que, $$18P=-P$$, porque $$16 \equiv -1 \mod 17$$, e por defini√ß√£o

$$
-P=(x_P,-y_P)
$$

Visto que o elemento neutro $$O$$ √© definido como $$P+(-P)$$, ent√£o

$$
19P = P + (-P) = O
$$

Voc√™ pode verificar esses resultados com o c√≥digo abaixo:

```python
def add_PQ(P, Q, a, p):
    O = (0,0) # Python n√£o compreende um elemento neutro no infinito, portanto usamos a origem.
    if P == O:
        return Q
    if Q == O:
        return P
    x1, y1 = P
    x2, y2 = Q
    if x1 == x2 and y1 == (p - y2) % p:
      return O
    if P != Q:
        s = ((y2 - y1) * pow(x2 - x1, -1, p)) % p
    else:
        s = ((3 * x1**2 + a) * pow(2 * y1,-1, p)) % p
    x3 = (s**2 - x1 - x2) % p
    y3 = (s * (x1 - x3) - y1) % p
    return x3, y3

def encontra_nP(k, P, a, p):
    # Double-and-add algorithm
    result = (0, 0)
    addend = P
    while k > 0:
        if k % 2 == 1:
            result = add_PQ(result, addend, a, p)
        addend = add_PQ(addend, addend, a, p)
        k //= 2
    return result

for i in range(2, 19):
		print(f"{i}P = {encontra_nP(i, (5,1), 2, 17)}")
```

### 4.5. Resumo:

Em geral, vale que na soma de dois pontos $$P=(x_P,y_P) \ e \ Q =(x_Q,y_Q)$$ pertencentes a curva el√≠ptica em $$‚Ñ§_p,\  p>3$$:

$$
P+Q=R=(x_R,y_R)
$$

$$
x_R\equiv s^2-x_P-x_Q \mod p
$$

$$
y_R\equiv s(x_P-x_R)-y_P \mod p
$$

$$
s=\begin{cases}
    (y_Q-y_P)\cdot(x_Q-x_P)^{-1} \mod p, & \text{se } P\neq Q\\
    ({3x_P}^2+a)\cdot(2y_P)^{-1} \mod p,& \text{se } P=Q
\end{cases}


$$

## 5. Variante de Menezes e Vanstone para o ElGamal

Em 1985, o Cript√≥grafo Taher Elgamal criou um sistema de criptografia baseado no **Problema do Logaritmo Discreto** em Curvas El√≠pticas, que usa um mecanismo p√∫blico de acordo de chaves, o **_Diffie-Hellman_**.

Dez anos depois, os matem√°ticos Alfred Menezes e Scott Vanstone elaboraram uma vers√£o alternativa para o ElGamal em que n√£o √© necess√°rio pr√©-codificar a mensagem como um ponto na curva. Esse sistema n√£o altera a seguran√ßa da criptografia e, por isso, vou usar como exemplo de Criptografia de Curvas El√≠pticas nesse material.

### 5.1. Problema do Logaritmo Discreto em Curvas El√≠pticas:

Dada uma curva el√≠ptica $$E$$ em $$‚Ñ§_{p}\ ,$$ para um $$p$$ muito grande. Consideramos um gerador $$P \in E$$, de ordem grande $$(\# E)$$.

A chave p√∫blica desse sistema √©:

$$
pub\_{key}=(‚Ñ§_{p}, E,P)
$$

J√° a chave privada vem do problema do logaritmo discreto,

$$
T=\underbrace{P+P+\dots+P+P+P}_\text{n vezes}=nP
$$

A dificuldade de decriptar uma mensagem se d√° em encontrar $$n$$ e, posteriormente, o seu inverso multiplicativo em $$‚Ñ§_{p}$$.

$$
priv\_key=n
$$

Veremos que, quando aplicamos o Diffie-Hellman esse problema tem o dobro de dificuldade, porque n√£o ser√° apenas um $$n$$ a ser encontrado. Na verdade, o atacante precisaria encontrar os inteiros $$n_A, n_B$$ a partir do gerador $$P$$ e pontos $$A, B$$ divulgados.

$$
A=n_A P
$$

$$
n_A=\log_{P}A
$$

$$
B=n_B P
$$

$$
n_B=\log_{P}B
$$

### 5.2. Diffie-Hellman (Troca de Chaves):

Suponha que dois amigos Alice e Bob querem testar essa criptografia em um canal p√∫blico.

Eles precisam entrar em consenso em quais ser√£o as chaves p√∫blica e privada, e para isso, Alice e Bob escolhem um inteiro $$n_A$$ e $$n_B$$ como suas chaves privadas.

Alice e Bob encontram os pontos $$A \ e \ B$$ e trocam essa informa√ß√£o no canal p√∫blico.

$$
A={n_A}P
$$

$$
B={n_B}P
$$

Com esses segredos compartilhados em m√£os, cada um obt√©m um novo ponto $$T$$ da curva que ser√° usado para encriptar a mensagem:

$$
T=n_BA=n_AB=n_A\ n_B \ P=(x_T,y_T)
$$

Nesse teste, Alice vai enviar a mensagem $$m$$ para Bob, mas n√£o √© poss√≠vel encriptar uma mensagem do tipo **_string_** sem qualquer pr√©-codifica√ß√£o.

### 5.3. Pr√©-Codifica√ß√£o da Mensagem:

Existem algumas formas de pr√©-codificar uma mensagem, mas a mais simples e intuitiva √© utilizando a tabela ASCII. Cada caractere da mensagem $$m$$ vai ser mapeado para um n√∫mero decimal.

Tabela ASCII. Retirado de asciicharstable.com

Por exemplo, a mensagem $$m=\text{"Processo Seletivo GRIS"}$$ ap√≥s convers√£o para tabela ASCII se torna

$$
\underbrace{080}_\text{P}\underbrace{114}_\text{r} \underbrace{111}_\text{o}\underbrace{099}_\text{c}\underbrace{101}_\text{e}\underbrace{115}_\text{s}\underbrace{115}_\text{s}\underbrace{111}_\text{o}\underbrace{032}_\text{" "}\underbrace{083}_\text{S}\underbrace{101}_\text{e}\underbrace{108}_\text{l}\underbrace{101}_\text{e}\underbrace{116}_\text{t}\underbrace{105}_\text{i}\underbrace{118}_\text{v}\underbrace{111}_\text{o}\underbrace{032}_\text{ " " }\underbrace{071}_\text{G}\underbrace{082}_\text{R}\underbrace{073}_\text{I}\underbrace{083}_\text{S}
$$

Contudo, ainda falta tornar essa mensagem um ponto no plano cartesiano, que ser√° feito ao quebrar em dois essa mensagem codificada, sempre com cautela para o valor de $$y$$ n√£o comece com zero.

$$
m= (m_1,m_2)=(80114111099101115115111032083101,108101116105118111032071082073083)
$$

### 5.4. Encriptando e Decriptando a Mensagem:

Como, Alice e Bob j√° trocaram suas chaves na etapa do Diffie-Hellman e ambos j√° possuem $$T$$, Alice encripta a mensagem $$m$$ em um simples passo.

$$
x_S\equiv x_T \cdot m_1 \mod p
$$

$$
y_S\equiv y_T \cdot m_2 \mod p
$$

Ela envia a mensagem encriptada $$(x_S,y_S)$$ para Bob, que por sua vez, pode decriptar a mensagem ao encontrar o inverso multiplicativo de $$x_T \ e \ y_T$$ em $$‚Ñ§_{p}$$

$$
x_T^{-1} \cdot x_S\equiv x_T^{-1} \cdot x_T\cdot m_1 \equiv m_1 \mod p
$$

$$
y_T^{-1} \cdot y_S\equiv y_T^{-1} \cdot y_T\cdot m_2 \equiv m_2 \mod p
$$

### 5.5. Exemplo:

Alice e Bob decidiram a chave p√∫blica em seu canal de comunica√ß√£o:

$$
p=
6846869858332693264879382366866797734569
$$

$$
E:y^2\equiv x^3+x+1 \mod p
$$

$$
P=(0,1)
$$

Eles geram dois n√∫meros inteiros grandes ‚Äúaleat√≥rios‚Äù para suas chaves privadas na etapa de Diffie-Hellman, calculam $$A={n_A}P \text{   e  } \ B={n_B}P$$ e enviam pelo canal esses pontos da curva:

$$
n_A=394756376
$$

$$
n_B=4857628576
$$

$$
A=n_AP\\


$$

$$
B={n_B}P
$$

$$
A=(1321558335145962274111597490867211013255,
$$

$$
4651129240009681064199578869499137918033)
$$

$$
B=(4220619002574924415163949286290416539523,


$$

$$
1790760103048364272577275779143881254580)
$$

Para Alice enviar a mensagem $$m=\text{"Processo Seletivo GRIS"}$$, ela deve primeiro calcular $$T=n_AB$$

$$
T=(3388592562391724595268718829924043980213,
$$

$$
129495594649667554566611905764330384728)
$$

Com a mensagem devidamente codificada com a tabela ASCII, basta Alice encontrar o ponto $$S$$, que √© a mensagem encriptada na curva.

$$
x_S\equiv x_T\cdot m_1 \mod p
$$

$$
y_S \equiv y_T \cdot m_2 \mod p
$$

$$
x_S\equiv 4529049851661077032801780682798255617077 \mod p
$$

$$
y_S\equiv 1642634166139862032990613753379881067558 \mod p
$$

Bob recebe o ponto $$S=(x_S,y_S)$$ e decripta com a chave privada $$T$$.

$$
m_1=80114111099101115115111032083101
$$

$$
m_2=108101116105118111032071082073083
$$

Para transformar de volta em texto, Bob junta as coordenadas $$m_1 \text{ e } m_2$$ em uma √∫nica string e faz um slice de tr√™s em tr√™s posi√ß√µes convertendo o c√≥digo ASCII (que sempre t√™m tr√™s d√≠gitos, apesar de alguns apresentarem um 0 na frente) para caractere.

$$
m=\text{"Processo Seletivo GRIS"}
$$

## 6. Assinatura Digital (ECDSA):

Uma assinatura digital tem como prop√≥sito identificar o Autor de uma mensagem de forma √∫nica, ou seja, somente o autor pode ser capaz de gerar sua assinatura digital. Assim, ele n√£o pode negar a autoria da mensagem.

Existem alguns algoritmos de assinatura digital, mas atualmente Criptografias de Curvas El√≠pticas s√£o amplamente utilizadas com esse prop√≥sito, principalmente porque elas usam chaves de menor tamanho e s√£o mais √°geis.

ECDSA (‚ÄùAlgoritmo de Assinatura Digital em Curvas El√≠pticas‚Äù em pt-BR) √© implementado desde a infraestrutura do certificado de seguran√ßa SSL e TLS, at√© endere√ßos de Bitcoins.

### 6.1. Algoritmo:

Suponha que os dois amigos Alice e Bob queiram testar agora o ECDSA. Para isso, eles devem concordar nos par√¢metros da curva:

$$
(E, \ P, \ p)
$$

onde $$P$$ √© um gerador em que a $$n=ord(P)$$ atenda duas condi√ß√µes importantes:

$$
ord(P)=\#E
$$

$$
ord(P) \text{ √© primo}
$$

Alice vai mandar a mesma mensagem $$m=\text{"Processo Seletivo GRIS"}$$, s√≥ que desta vez ela vai assinar usando ECDSA, que ela faz da seguinte forma:

Ela gera um n√∫mero inteiro $$d_A$$ aleat√≥rio do intervalo $$[1, n-1]$$ como sua chave privada e calcula o ponto da curva $$Q_{A}=d_A\times P$$ como chave p√∫blica. Com isso em m√£os, ela vai seguir o algoritmo abaixo

$$
\text{1. Calcule a hash dessa mensagem:} \ e= \text{HASH}(m)\\


$$

$$
\text{2. Considere } z \text{ como os } L_n \text{ bits mais √† esquerda de }  e \text{,}\\ \text{ onde } L_n \text{ √© o comprimento de bit de ord(P)}


$$

$$
\text{3. Escolha k no intervalo } [1, n-1] \text{}


$$

$$
\text{4. Calcule } (x_1,y_1)=k\times P


$$

$$
\text{5. Calcule } r\equiv x_1 \mod n \text{ e se r=0, volte para a etapa 3}


$$

$$
\text{6. Calcule } s\equiv k^{-1} (z+r\cdot d_A) \mod n \text{ e se s=0, volte para a etapa 3}
$$

No final desse processo, Alice obt√©m o par $$(r,s)$$ que √© a sua assinatura digital em ECDSA.

### 6.2. Verifica√ß√£o de Assinatura:

Ap√≥s Bob receber a mensagem com a assinatura de Alice, ele pode autenticar a mesma utilizando a chave p√∫blica previamente acordada.

Antes de tudo, ele verifica se $$Q_A \in E$$ ao calcular $$n\times Q_A$$. Se resultar no elemento neutro $$O$$ , a assinatura √© autentica. Entretando, Bob ainda tem que descobrir se essa assinatura pertence a Alice.

$$
\text{1. Verifica se } r,s\in[1,n-1]
$$

$$
\text{2. Calcule } e=\text{HASH}(m)
$$

$$
\text{3. Considere z como os } L_n \text{ bits mais √† esquerda de } e
$$

$$
\text{4. Encontre o inverso multiplicativo de } s \text{ em }  ‚Ñ§_n: w\equiv s^{-1} \mod n
$$

$$
\text{5. Calcule } u_1 = zw \mod n  \text{   e  } u_2\equiv rw \mod n
$$

$$
\text{6. Calcule o ponto da curva } (x_1,y_1)=u_1\times P+u_2\times Q_A, \text{ se }  (x_1,y_1)=O \text{ √© invalida}
$$

$$
\text{7. Se } r\equiv x_1\mod n \text{, a assinatura √© valida}
$$

### 6.3. PS3 Jailbreak - fail0verfl0w:

Se um mesmo $$k$$ for usado para assinar duas mensagens distintas, √© poss√≠vel recuperar a chave privada do autor atrav√©s de algumas simples opera√ß√µes.

Lembrando que, $$k$$ igual para duas assinaturas implica em $$r$$ ser o mesmo tamb√©m, visto que

$$
r=(k\times P)_x \mod n
$$

Contudo, $$k$$ igual n√£o implica em $$s$$ iguais para duas assinaturas. Na verdade, esse fato d√° brecha para um ataque.

Suponha que temos duas mensagens diferentes de hashes $$z_1 \text{ e } z_2$$, respectivamente. O inverso multiplicativo de $$k$$ continua sendo o mesmo, tanto para $$s_1$$ quanto para $$s_2$$, assim como $$rd_A$$.

$$
s_1\equiv((z_1+rd_A)\cdot k^{-1}) \mod n
$$

$$
s_2\equiv((z_2+rd_A)\cdot k^{-1}) \mod n
$$

Assim, com uma simples manipula√ß√£o alg√©brica,

$$
s_1-s_2\equiv((z_1+rd_A)\cdot k^{-1})-((z_2+rd_A)\cdot k^{-1}) \mod n
$$

$$
(z_1+rd_A-z_2-rd_A)\cdot k^{-1} \equiv(z_1-z_2)\cdot k^{-1} \mod n
$$

Mas isso tudo √© congruente a diferen√ßa de $$s_1$$ e $$s_2$$

$$
(s_1-s_2)\equiv (z_1-z_2)\cdot k^{-1} \mod n
$$

Multiplicando $$k$$ de ambos os lados,

$$
(s_1-s_2)\cdot k\equiv (z_1-z_2) \mod n
$$

Sendo assim, $$k$$ pode ser facilmente obtido com o c√°lculo abaixo:

$$
k\equiv (z_1-z_2)\cdot(s_1-s_2)^{-1} \mod n
$$

Com $$k$$ em m√£os, √© poss√≠vel colocar $$d_A$$ em evid√™ncia a partir da congru√™ncia

$$
s_1\equiv((z_1+rd_A)\cdot k^{-1}) \mod n
$$

Novamente, multiplica-se $$k$$ de ambos os lados,

$$
(z_1+rd_A)\equiv s_1 \cdot k\mod n
$$

$$
rd_A\equiv (s_1 \cdot k -z_1) \mod n
$$

Portanto, a chave privada √© a solu√ß√£o de

$$
d_A\equiv (s_1 \cdot k - z_1) \cdot r^{-1} \mod n
$$

## 7. POSTs:

Para o POST de voc√™s, elaborei 3 challs de n√≠veis **_f√°cil_**, **_m√©dio_** e **_m√©dio plus_**.

Tudo que voc√™ precisa para resolver esses POSTs est√° nesse material, basta procurar com aten√ß√£o.

No geral est√£o bem tranquilos, n√£o fiquem assustados pelo tamanho do material, porque eu garanti que voc√™s n√£o v√£o precisar escrever mais do que tr√™s linhas de c√≥digo no Python para pegar a flag. Caso n√£o tenham instalado Python no computador ainda, voc√™s podem passar esse c√≥digo para o [https://colab.research.google.com](https://colab.research.google.com/) e obter a flag por ali.

Al√©m disso, eu escolhi n√£o colocar os n√∫meros nos enunciados abaixo e sim direto no c√≥digo, porque s√£o muito grandes e pode acabar confundindo na hora de ler o comando da quest√£o, ent√£o n√£o se preocupem em copiar eles, j√° est√° tudo no arquivo .py.

Voc√™s podem me consultar a qualquer momento, at√© mesmo para aux√≠lio na linguagem Python.

Boa Sorte! =D

**ATEN√á√ÉO: TODAS AS FLAGS EST√ÉO NO FORMATO CTF-BR{flag}**

### 7.1. Onde est√° Stuart Little? **(F√°cil)**

Tr√™s ratos foram fazer um passeio em uma Curva El√≠ptica

$$
E:y^2\equiv x^3-3x+4 \mod 43
$$

Stuart Little se perdeu de seus amigos Mickey e Jerry, e eles precisam de ajuda para encontr√°-lo.

Sabendo que Mickey est√° no ponto $$P=(14,37)$$, Jerry no ponto $$Q=(14,-37)$$, e que a soma $$P+Q$$ √© onde o Stuart Little est√°, responda o ponto (em caps-lock) que representa a posi√ß√£o de Stuart Little.

Por exemplo, se Stuart Little estivesse no ponto $$S$$, voc√™s responderiam $$\text{CTF-BR{S}}$$

### 7.2. ElGaton **(M√©dio)**

(N√£o se preocupem em copiar esses n√∫meros para o c√≥digo, j√° coloquei no arquivo .py)

Meu gato Frodo implementou um novo sistema de criptografia baseado em curvas el√≠pticas chamado ElGaton (qualquer semelhan√ßa com o ElGamal √© apenas uma mera coincid√™ncia ü§´).

Frodo quer usar o ElGaton para se comunicar com meu outro gato Sam, e eu descobri que a chave p√∫blica dessa criptografia √©:

- A curva el√≠ptica $$E: y^2 \equiv x^3+ax+b \mod p$$
- O m√≥dulo primo $$p$$
- O gerador $$P$$

Eu consegui interceptar uma das mensagens trocadas entre eles e, enquanto isso, meu outro gato Gollum encontrou o segredo compartilhado do Sam e a chave privada do Frodo para o Diffie-Hellman:

<ul>
<li>
$$Q_{sam}=(246061765250195212969506118903120091083185433952208069588975, $$
</li>
$$ 
9343754362889750569766954041373414358787687742337204027292453)
$$
<li> $$n_{frodo}=233336110442550297617299$$ </li>
</ul>
Lembrando que

$$
Q_{sam}\equiv n_{sam} \cdot P \mod p
$$

Voc√™ pode me ajudar a decriptar a mensagem?

$$
S=(109105097117095109051048119095109101048119095109105052117,
$$

$$
95109051111119095109101111119095109049097117095109049052117)
$$

```python
from Crypto.Util.number import long_to_bytes
def add_PQ(P, Q, a, p):
  O = (0,0)
  if P == O:
    return Q
  if Q == O:
    return P
  x1, y1 = P[0], P[1]
  x2, y2 = Q[0], Q[1]

  if x1 == x2 and y1 == (p-y2) % p:
    return O

  if P != Q:
    s = ((y2-y1) * pow(x2-x1, -1, p)) % p
  else:
    s = ((3 * x1**2 + a)*pow(2*y1, -1, p)) % p
  x3 = (s**2 - x1 - x2) % p
  y3 = (s*(x1-x3) - y1) % p
  return x3,y3

def encontra_nP(k, P, a, p):
    result = (0, 0)
    addend = P
    while k > 0:
        if k % 2 == 1:
            result = add_PQ(result, addend, a, p)
        addend = add_PQ(addend, addend, a, p)
        k //= 2
    return result

# Chave P√∫blica
# y^2 = x^3 +ax +b (mod p)
a = 15347898055371580590890576721314318823207531963035637503096292
b = 7444386449934505970367865204569124728350661870959593404279615

P = (1619092589586542907492569170434842128165755668543894279235270,
     3436949547626524920645513316569700140535482973634182925459687)

p = 17676318486848893030961583018778670610489016512983351739677143

# Mensagem Encriptada
S = (334723336424414961000482608007001766504544326753246721049147, 12254736703215694149846183808068667208423268069978932609288223)

# Diffie-Helmann

Q_sam= (246061765250195212969506118903120091083185433952208069588975,9343754362889750569766954041373414358787687742337204027292453)

n_frodo = 233336110442550297617299

# Altere SOMENTE esse trecho abaixo para obter a mensagem decriptada
# Um exemplo seria: 3P = encontra_nP(3,P,a,p)
T = encontra_nP(INSIRA OS PARAMETROS CORRETOS)

dec_x = ?
dec_y = ?
# At√© aqui

# Essa fun√ß√£o retorna a flag, basta alterar o trecho acima e voc√™ ter√° a resposta =)
print(long_to_bytes(int(str(dec_x)+""+str(dec_y))))
```

### 7.2. Tem na PrimeVideo **(M√©dio Plus)**

Os dois amigos Alex e Rosie trocavam cartas todo m√™s, at√© que decidiram assinar digitalmente suas mensagens usando o ECDSA.

Alex enviou duas mensagens para Rosie, mas propositalmente usou um mesmo $$k$$ nessas assinaturas para que Rosie encontrasse sua chave privada. Ele disse que escondeu nessa chave um filme para assistirem juntos depois.

Voc√™ pode ajudar Rosie a encontrar a chave $$d_A$$?

```python
import hashlib

def sha1(mensagem):
  m = hashlib.sha1()
  m.update(mensagem.encode('utf-8'))
  return m.hexdigest()

def get_flag(dA):
  flagg = str(dA)
  flag = ""
  for i in range(0, len(flagg), 3):
    ascii_value = int(flagg[i:i+3])
    flag += chr(ascii_value)
  return flag

# m√≥dulo n
n = 656563738156183614196284144218755562218717754449979872699851236361364842254951562533589572185811735734269627798779142529399297211938766368323781389974849197211221357383295846145542699614912769848476126126824744284474444862644897675458539907 # m√≥dulo n

# Assinatura Digital 1 (Perceba que r √© igual para as duas assinaturas)
r=95607856998428856962864667427230197797741826906987352066517618702726741034205788706243608221638336439218766183440425733114479831314017676199460278142286425537126711154511562912579612912784188540749745708743557963162626080980370058843390766
s1=165157211993616791859199000937589933684499917729542174996499818375298323939989753112300163308344922630103779318855607444007576610685510915409036097807215683429601907707404696743146600439769894499636383677085373291440501432136786127232184960
mensagem1 = "There's the pangs of time, there's the undiscover'd country from whose bourn no traveller returns, puzzles the native hue of resolution devoutly to be: that the unworthy takes, when he himself might his quietus make with and the respect that flesh is heir to, 'tis a consience of outrageous fortune, or not to be wish'd. To die: to sleep to sleep to sleep; to suffer the spurns that makes calamity of something after death, the rub; for in that sleep; to sleep to sleep; to sleep; to sleep; to sleep to suf"

# Assinatura Digital 2
r=95607856998428856962864667427230197797741826906987352066517618702726741034205788706243608221638336439218766183440425733114479831314017676199460278142286425537126711154511562912579612912784188540749745708743557963162626080980370058843390766
s2=655257327074735825941539460803878702931540821094751678069186258593203560380164175950374129122241488762716003739831883556274219200303701610167842447024906266687095907769369448831845421539179487468728385173083899901112733508707733874252121923
mensagem2 = "What down at the name of Sanders. (What down at the forest all by himself. It went like that, just buzzing, he climb the tree, there came to an open place was a large oak-tree, and as he had the forest, and in the middle of Sanders. (What does under it. So he began to climbed, and began to think. First of the tree, and lived under the top of there came to an open place in the only reason for making a bee. Then he thought another long time, and buzzing and as he climbed and he sang a buzzing-noise"z1,z2 = int(sha1(mensagem1), 16), int(sha1(mensagem2), 16)

# k = ?

# dA = ?

# Desafio acaba aqui! =)
flag="CTF-BR{"+ f"{get_flag(dA)}" + "}"
print(flag)
```
